# -*- coding: utf-8 -*-
"""Copia de programa del mauri con colores

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wn34-gMHmrEuGnfTGjaftWM1KxRtCE-F

Instalacion de librerias adicionales al entorno de colaboratory
"""

!pip install ezdxf
!pip install geopandas

"""Código fuente para la lectura del Autocad inicial, donde se separan los pilares originales y los de área tributaria"""

import sys
import math
import ezdxf
import pandas as pd
import numpy as np
import geopandas as geo
from shapely.geometry import *



doc = ezdxf.readfile("Ejercicio_Inicio.dxf")


lista_eje_x = []
lista_eje_y = []
lista_start_width = []
lista_end_width = []
lista_bulge = []
lista_polilinea = []
distancias = []
capa_polilinea = []


msp = doc.modelspace()

for e in msp:
    if e.dxftype() == "LWPOLYLINE":
        print("la", e, "tiene",len(e), "segmentos de rectas")
        i = 0
        while i < len(e):
            if i == 0:
                distancias.append(0)
            else:
                distancias.append(math.dist([e[i-1][0] ,e[i-1][1] ], [ e[i][0] ,e[i][1] ]))
            print(e[i])
            lista_polilinea.append(e)
            lista_eje_x.append(e[i][0])
            lista_eje_y.append(e[i][1])
            lista_start_width.append(e[i][2])
            lista_end_width.append(e[i][3])
            lista_bulge.append(e[i][4])
            capa_polilinea.append(e.dxf.layer)
            i = i + 1 
    datos = pd.DataFrame(data = {"polilinea": lista_polilinea, "x": lista_eje_x, 
                                 "y": lista_eje_y, "capa": capa_polilinea})

    datos.to_excel("Datos de acad ver 777.xlsx", sheet_name= "polilineas")
    
elemento_unicos = []
for i in lista_polilinea:
    if i not in elemento_unicos:
        elemento_unicos.append(i)
        
print(elemento_unicos)
print(len(elemento_unicos))

nombre_gen = []
x_gen = []
y_gen = []
capa_gen = []
puntos_gen = []

i = 0
while i < len(elemento_unicos):
    z = 0
    nombre = []
    x = []
    y = []
    capa = []
    puntos = []
    data_1 = datos[datos["polilinea"] == elemento_unicos[i]]
    while z < len(data_1):
        nombre.append(data_1.iloc[z, 0])
        x.append(data_1.iloc[z, 1])
        y.append(data_1.iloc[z, 2])
        capa.append(data_1.iloc[z, 3])
#        punto = list(zip(x, y))
#        puntos.append(punto)
        z = z + 1
    punto = list(zip(x,y))
    nombre_gen.append(nombre)
    x_gen.append(x)
    y_gen.append(y)
    capa_gen.append(capa)
    puntos_gen.append(punto)
    i = i + 1

print(nombre_gen)
print(x_gen)
print(y_gen)
print(capa_gen)
print(len(puntos_gen))
print(puntos_gen[0])



lista_nombre = []
i = 0
while i < len(nombre_gen):
    lista_nombre.append(nombre_gen[i][0])
    i = i + 1
    
lista_capa = []
i = 0
while i < len(capa_gen):
    lista_capa.append(capa_gen[i][0])
    i = i + 1

print(lista_nombre)
print(lista_capa)


############ creacion de poligonos ############



i = 0
lista_polygon = []
lista_centroide = []
lista_area = []
lista_perimetro = []
while i < len(lista_nombre):
    s1 = Polygon(puntos_gen[i])
    lista_area.append(s1.area)
    lista_centroide.append(s1.centroid)
    lista_polygon.append(s1)
    lista_perimetro.append(s1.length)
    i = i + 1
    
#print(polygon)
print(lista_area)

data = geo.GeoDataFrame({"nombre": lista_nombre, "polygon": lista_polygon, "capa": lista_capa, "area": lista_area, 
                         "centroide": lista_centroide, "perimetro" : lista_perimetro})
data.to_excel("polygonos a lo fino.xlsx")




####################################################################################
data_dios = pd.DataFrame(columns = ["nombre x", "capa x", "area x", "nombre y", "capa y", "area y",
                                    "distancia"])
lista_distancias_geo = []
lista_nombres_geo = []

z = 0
while z < len(data):
    lista_distancias = []
    lista_nombres = []
    lista_x = []
    lista_y = []
    lista_x_capa = []
    lista_y_capa = []
    lista_x_area = []
    lista_y_area = []
    lista_x_perimetro = []
    lista_y_perimetro = []
    i = 0
    while i < len(data):
        dista = (data.iloc[z, 4]).distance(data.iloc[i, 4])
        lista_distancias.append(dista)
        x = data["nombre"][z]
        y = data["nombre"][i]
        nombre = list([str(x), str(y)])
        lista_nombres.append(nombre)
        lista_x.append(x)
        lista_y.append(y)
        ##################################
        lista_x_capa.append(data["capa"][z])
        lista_y_capa.append(data["capa"][i])
        lista_x_area.append(data["area"][z])
        lista_y_area.append(data["area"][i])
        lista_x_perimetro.append(data["perimetro"][z])
        lista_y_perimetro.append(data["perimetro"][i])
 #       data = pd.DataFrame({"nombre": nombre, "distancia": lista_distancias})
        i = i + 1
 #   datagene.append([nombre, dista])
    data_refe = pd.DataFrame({"nombre x": lista_x, "capa x": lista_x_capa ,"area x": lista_x_area,
                              "nombre y": lista_y, 
                              "capa y": lista_y_capa,
                              "area y": lista_y_area, "distancia": lista_distancias, "perimetro x": lista_x_perimetro, "perimetro y": lista_y_perimetro })
    data_filtro = data_refe[data_refe["nombre y"] != x]
    valor = data_filtro["distancia"].min()
    fila_min = data_filtro[data_filtro["distancia"] == valor]
    data_dios = pd.concat([data_dios, fila_min])
    
    lista_distancias_geo.append(lista_distancias)
    lista_nombres_geo.append(lista_nombres)
    z = z + 1

print(lista_distancias_geo)
print(lista_nombres_geo)
print(lista_x)
print(len(lista_x))
print(lista_y)
print(len(lista_y))
print(lista_distancias)
print(len(lista_distancias))
print(data_refe)
print(data_filtro)
print(valor)
print(fila_min)

print(data_dios)
data_dios.to_excel("resultados finales.xlsx")

#############################################################
data_final = data_dios

data_final_2 = data_final[data_final["capa y"] == "Pilares_Ejemplo"]

print(data_final_2)


data_resumen = pd.DataFrame({"pilar": data_final_2["nombre x"], 
                             "tipo de pilar": data_final_2["capa x"], 
                             "Área": data_final_2["area x"], 
                             "Área Tributaria": data_final_2["area y"], "perimetro": data_final_2["perimetro x"]})

print(data_resumen)

data_resumen["At/Ap"] = data_resumen["Área Tributaria"]/data_resumen["Área"]

print(data_resumen)

data_resumen.to_excel("resultados de los datos4.xlsx")

"""data_resumen es un dataframe que contiene la información de todos los pilares que existan en el archivo CAD, segmentados segun su tipo de pilar, entre otras caracteristicas"""

data_resumen

altura = float(input("ingresa la altura del pilar en metros: "))
data_resumen["Altura"] = altura

data_resumen

data_resumen2 = data_resumen.copy()

"""Lectura del excel que contiene las propiedad geomecanicas de CMET y PDI"""

prop_geo = pd.read_excel("/content/propiedades geomecanicas.xlsx")

prop_geo

x = data_resumen2
y = prop_geo


lista_sigma_ci = []
lista_mi = []
lista_gsi = []


for i in x["tipo de pilar"]:
  if i == "CMET":
    HOLA = y[y["Litologia"] == "CMET"]
    lista_sigma_ci.append(HOLA.iloc[0,1])
    lista_mi.append(HOLA.iloc[0, 2])
    lista_gsi.append(HOLA.iloc[0, 3])


  if i == "PDI":
    HOLA = y[y["Litologia"] == "PDI"]
    lista_sigma_ci.append(HOLA.iloc[0,1])
    lista_mi.append(HOLA.iloc[0, 2])
    lista_gsi.append(HOLA.iloc[0, 3])
    
x["Sigma_ci"] = lista_sigma_ci
x["mi"] = lista_mi
x["GSI"] = lista_gsi

"""x es un dataframe que contiene toda la informacion importante acerca de la geometria de cada pilar, asi como de las caracteristicas geomecánicas"""

x

"""##Nuestro x es nuestra tabla final """

esf_v = float(input("ingrese el valor del esfuerzo vertical en MPa: "))
x["esfuerzo vertical"] = esf_v

x

x["Radio Hidráulico"] = x["Área"]/x["perimetro"]

factor_perturbacion = float(input("ingrese el factor de perturbacion por tronadura: ")) ## valor por defecto de d es 0

x["D"] = factor_perturbacion

x["ancho efectivo"] = 4*x["Radio Hidráulico"]
x["esbeltez minera"] = x["ancho efectivo"]/x["Altura"]
x["razón alto ancho"] = 1/x["esbeltez minera"]
x["mb"] = x["mi"] * np.exp((x["GSI"]-100)/(28-(14*x["D"])))
x["s"] = np.exp((x["GSI"]-100)/(9-(3*x["D"])))
x["a"] = 0.5 + ( (1/6)* (np.exp(-1*(x["GSI"]/15) ) - np.exp(-20/3 )) )
x["sigma aplicado"] = x["esfuerzo vertical"]*x["At/Ap"]
x["sigma 3"] = x["sigma aplicado"]*(-0.15267211+(0.22690402/(np.sqrt(x["razón alto ancho"]))))
x["sigma maximo"] = x["sigma 3"]+ ( x["Sigma_ci"]* (np.power(( x["mb"]*(x["sigma 3"]/x["Sigma_ci"]) )+ x["s"], x["a"])))
x["factor de seguridad"] = x["sigma maximo"]/ x["sigma aplicado"]

x.to_excel("resultados finales finales 2.xlsx")

"""##Extracción de la informacion al ACAD
en las siguientes lineas se presenta el proceso de extracion de la informacion que existe en x, para crear al CAD que visualmente representara la solución
"""

resultados = x.copy()

resultados

"""resultados_2 es un dataframe que contiene las 3 columnas mas importante donde se evaluara el tipo de pilar, sus coordenadas y el factor de seguridad"""

resultados_2 = resultados[["pilar", "tipo de pilar", "factor de seguridad"]]

resultados_2

resultados_2.to_excel("resultados_2.xlsx")

"""##proceso de creacion del CAD"""

###### Creacion del codigo para las coordenadas de cada polilinea ######
#####################################################
#####################################################

i = 0
polilineas = []
centroides = []
while i < len(resultados_2):
  lista_x = []
  lista_y = []
#  lista_centroides = []
  largo = len(resultados_2.iloc[i, 0])
  z = 0
  while z < largo: 
    lista_x.append(resultados_2.iloc[i, 0][z][0]) ### apendiza a la lista la coor X
    lista_y.append(resultados_2.iloc[i, 0][z][1]) ### apendiza a la lista la coor Y 

    z = z + 1
  lista_zip = list(zip(lista_x, lista_y))
  print("la lista zip es:")
  print(lista_zip)
  polilineas.append(lista_zip)
  p = Polygon(lista_zip)
  centroide = p.centroid
  centroides.append(centroide)
  i = i + 1

"""Estandarización de los valores del factor de seguridad para poder crear la escalas de colores para la visualización de cada pilar en el archivo CAD"""

fs = resultados_2["factor de seguridad"].values

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range= (10,170)) ### valores importantes para el escalado de la variable FS

trans_fs = scaler.fit_transform(fs.reshape(-1, 1))

trans_fs_round = trans_fs.round(-1)

trans_fs_round

"""con escala de color segun la configuracion ACI"""

###### Creacion del AUTOCAD #######
#########################################################################################
#########################################################################################
from ezdxf.enums import TextEntityAlignment
doc = ezdxf.new("R2018", setup = True)
msp = doc.modelspace()
i = 0
while i < len(resultados_2["pilar"]):
  hatch = msp.add_hatch(color= float(trans_fs_round[i]), ) ### AJUSTAR LOS COLORES
#  hatch.set_pattern_fill("ANSI31", scale=0.5, color = float(trans_fs_round[i])) ### AJUSTAR LOS COLORES
  a = resultados_2.iloc[i, 0] ## busqueda de la linea 
  b = resultados_2.iloc[i, 1] ## busqueda de la capa 
  c = resultados_2.iloc[i, 2] ## valor del FS
  d = centroides[i]  ### valor de los centroides
  msp.add_lwpolyline(a, close = True, dxfattribs= {"layer": str(b)})
  msp.add_text(("FS :", str(c.round(3))), height= 1, dxfattribs={"style": "LiberationSerif"}
               ).set_placement((d.x , d.y), align=TextEntityAlignment.LEFT)
  hatch.paths.add_polyline_path(polilineas[i], is_closed=True)
  i = i + 1

doc.saveas("AUTOCAD DE SALIDA 3.dxf")

"""con escala rgb"""

fs = resultados_2["factor de seguridad"].values

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range= (0, 252)) ### valores importantes para el escalado de la variable FS

trans_fs = scaler.fit_transform(fs.reshape(-1, 1))

trans_fs_round = trans_fs.round(-1)

trans_fs_round

trans_fs_round[0]

hatch = msp.add_hatch(color = 2)

hatch.set_dxf_attrib("color", 1)



###### Creacion del AUTOCAD #######
#########################################################################################
#########################################################################################
from ezdxf.enums import TextEntityAlignment
doc = ezdxf.new("R2018", setup = True)
msp = doc.modelspace()
i = 0
while i < len(resultados_2["pilar"]):
  c = ezdxf.colors.rgb2int((255, int(trans_fs[i]), 0))
  hatch = msp.add_hatch(color= c ) ### AJUSTAR LOS COLORES
#  hatch.set_pattern_fill("ANSI31", scale=0.5, color = float(trans_fs_round[i])) ### AJUSTAR LOS COLORES
  a = resultados_2.iloc[i, 0] ## busqueda de la linea 
  b = resultados_2.iloc[i, 1] ## busqueda de la capa 
  c = resultados_2.iloc[i, 2] ## valor del FS
  d = centroides[i]  ### valor de los centroides
  msp.add_lwpolyline(a, close = True, dxfattribs= {"layer": str(b)})
  msp.add_text(("FS :", str(c.round(3))), height= 1.5, dxfattribs={"style": "LiberationSerif"}
               ).set_placement((d.x , d.y), align=TextEntityAlignment.LEFT)
  hatch.paths.add_polyline_path(polilineas[i], is_closed=True)
  i = i + 1
doc.saveas("beto 3.dxf")

###### Creacion del AUTOCAD #######
#########################################################################################
#########################################################################################
from ezdxf.enums import TextEntityAlignment
doc = ezdxf.new("R2018", setup = True)
msp = doc.modelspace()
i = 0
while i < len(resultados_2["pilar"]):
  c = ezdxf.colors.rgb2int((255, int(trans_fs[i]), 0))
  hatch = msp.add_hatch() ### AJUSTAR LOS COLORES
  dd = int(trans_fs_round[i])
  hatch.rgb = (255, dd, 0)
#  hatch.set_pattern_fill("ANSI31", scale=0.5, color = float(trans_fs_round[i])) ### AJUSTAR LOS COLORES
  a = resultados_2.iloc[i, 0] ## busqueda de la linea 
  b = resultados_2.iloc[i, 1] ## busqueda de la capa 
  c = resultados_2.iloc[i, 2] ## valor del FS
  d = centroides[i]  ### valor de los centroides
  msp.add_lwpolyline(a, close = True, dxfattribs= {"layer": str(b)})
  msp.add_text(("FS :", str(c.round(3))), height= 1.5, dxfattribs={"style": "LiberationSerif", "color": 182}
               ).set_placement((d.x , d.y), align=TextEntityAlignment.LEFT)
  hatch.paths.add_polyline_path(polilineas[i], is_closed=True)
  i = i + 1
doc.saveas("beto 9.dxf")

entity.dxf.true_color = ezdxf.colors.rgb2int(255, 128, 16)

###### Creacion del AUTOCAD #######
#########################################################################################
#########################################################################################
from ezdxf.enums import TextEntityAlignment
doc = ezdxf.new("R2018", setup = True)
msp = doc.modelspace()
i = 0
while i < len(resultados_2["pilar"]):
  c = ezdxf.colors.rgb2int((255, int(trans_fs[i]), 0))
  hatch = msp.add_hatch() ### AJUSTAR LOS COLORES
  dd = int(trans_fs_round[i])
  hatch.rgb = (255, dd, 0)
#  hatch.set_pattern_fill("ANSI31", scale=0.5, color = float(trans_fs_round[i])) ### AJUSTAR LOS COLORES
  a = resultados_2.iloc[i, 0] ## busqueda de la linea 
  b = resultados_2.iloc[i, 1] ## busqueda de la capa 
  c = resultados_2.iloc[i, 2] ## valor del FS
  d = centroides[i]  ### valor de los centroides
  msp.add_lwpolyline(a, close = True, dxfattribs= {"layer": str(b)})
  mtext = msp.add_mtext(("FS :", str(c.round(3))), dxfattribs={"style": "OpenSans_Narrow", "color": 5}) ### color y estilo de la letra
  mtext.dxf.char_height = 1
  mtext.set_bg_color(7, scale=1.5) ### color de fondo 
#  mtext.set_placement( d.x, d.y)
  mtext.set_location(attachment_point = 5, insert = (d.x, d.y))


#  msp.add_text(("FS :", str(c.round(3))), height= 1.5, dxfattribs={"style": "LiberationSerif", "color": 182}
#               ).set_placement((d.x , d.y), align=TextEntityAlignment.LEFT)
  hatch.paths.add_polyline_path(polilineas[i], is_closed=True)
  i = i + 1
doc.saveas("beto 14.dxf")

c

## funcion que transforma los colores de rgb a ACI 

ezdxf.colors.rgb2int((240,248,255))

ezdxf.colors.rgb2int((255, int(trans_fs_round[0]), 0))



type(ezdxf.colors.rgb2int((240,248,255)))





(240,248,255)





"""### FIN DEL PROGRAMA"""

#######################################################################################################################################



lista_x = []
lista_y = []
i = 0
while i <  len(resultados_2["pilar"]):
  lista_x.append(resultados_2.iloc[i, 0][-1][0])
  lista_y.append(resultados_2.iloc[i, 0][-1][1])
  i = i + 1

### valores del ultimo punto en cada polilinea
print(lista_x, lista_y)

ultimas_coor = list(zip(lista_x, lista_y))

ultimas_coor

ultimas_coor

p1 = Polygon(ultimas_coor)



lista_a = []
lista_b = []

for i in resultados_2["pilar"]:
  lista_a.append(resultados_2.iloc[0,0][i][0])

print(resultados_2.iloc[3, 0])

a = resultados_2.iloc[0, 0]

print(a[0])



doc = ezdxf.new("R2000")
msp = doc.modelspace()
i = 0
while i < len(resultados_2["pilar"]):
  a = resultados_2.iloc[i, 0] ## busqueda de la linea 
  b = resultados_2.iloc[i, 1] ## busqueda de la capa 
  msp.add_lwpolyline(a, close = True, dxfattribs= {"layer": str(b)})
  i = i + 1
doc.saveas("polilineas_de_pruebas_4.dxf")

fs = resultados_2.iloc[0, 2]
print(fs.round(3))
print("el valor del factor de seguridad es:", str(fs))

aa = resultados_2.iloc[3, 0]
print(len(aa))

###### Creacion del codigo para los centroides ######
#####################################################
#####################################################

i = 0
centroides = []
while i < len(resultados_2):
  lista_x = []
  lista_y = []
#  lista_centroides = []
  largo = len(resultados_2.iloc[i, 0])
  z = 0
  while z < largo: 
    lista_x.append(resultados_2.iloc[i, 0][z][0])
    lista_y.append(resultados_2.iloc[i, 0][z][1])

    z = z + 1
  lista_zip = list(zip(lista_x, lista_y))
  print("la lista zip es:")
  print(lista_zip)
  p = Polygon(lista_zip)
  centroide = p.centroid
  centroides.append(centroide)
  i = i + 1

centroides

a = centroides[0]
b = a.x
print(a.x)
type(b)

data_centroides = geo.GeoDataFrame({"centroide": centroides})

data_centroides.iloc[0, 0]



###### Creacion del AUTOCAD #######
#########################################################################################
#########################################################################################
from ezdxf.enums import TextEntityAlignment
doc = ezdxf.new("R2018", setup = True)
msp = doc.modelspace()
i = 0
while i < len(resultados_2["pilar"]):
  a = resultados_2.iloc[i, 0] ## busqueda de la linea 
  b = resultados_2.iloc[i, 1] ## busqueda de la capa 
  c = resultados_2.iloc[i, 2] ## valor del FS
  d = centroides[i]  ### valor de los centroides
  msp.add_lwpolyline(a, close = True, dxfattribs= {"layer": str(b)})
  msp.add_text(("FS :", str(c.round(3))), height= 1, dxfattribs={"style": "LiberationSerif"}
               ).set_placement((d.x , d.y), align=TextEntityAlignment.LEFT)
  i = i + 1
doc.saveas("polilineas_de_pruebas_12.dxf")

"""#Pruebas de los colores

codigo importante que sirve para obtener las direcciones del centroide y las coordenadas de cada polilinea para el achurado con color
"""

###### Creacion del codigo para las coordenadas de cada polilinea ######
#####################################################
#####################################################

i = 0
polilineas = []
while i < len(resultados_2):
  lista_x = []
  lista_y = []
#  lista_centroides = []
  largo = len(resultados_2.iloc[i, 0])
  z = 0
  while z < largo: 
    lista_x.append(resultados_2.iloc[i, 0][z][0]) ### apendiza a la lista la coor X
    lista_y.append(resultados_2.iloc[i, 0][z][1]) ### apendiza a la lista la coor Y 

    z = z + 1
  lista_zip = list(zip(lista_x, lista_y))
  print("la lista zip es:")
  print(lista_zip)
  polilineas.append(lista_zip)
  p = Polygon(lista_zip)
  centroide = p.centroid
  centroides.append(centroide)
  i = i + 1

polilineas[0]

lista_zip

aa = np.array(resultados_2.iloc[0,0])

aa

"""creacion del autocad"""

###### Creacion del AUTOCAD #######
#########################################################################################
#########################################################################################
from ezdxf.enums import TextEntityAlignment
doc = ezdxf.new("R2018", setup = True)
msp = doc.modelspace()
i = 0
while i < len(resultados_2["pilar"]):
  hatch = msp.add_hatch(color= 253) ### AJUSTAR LOS COLORES
  hatch.set_pattern_fill("ANSI31", scale=0.5, color = 170) ### AJUSTAR LOS COLORES
  a = resultados_2.iloc[i, 0] ## busqueda de la linea 
  b = resultados_2.iloc[i, 1] ## busqueda de la capa 
  c = resultados_2.iloc[i, 2] ## valor del FS
  d = centroides[i]  ### valor de los centroides
  msp.add_lwpolyline(a, close = True, dxfattribs= {"layer": str(b)})

  mtext = msp.add_mtext(("FS :", str(c.round(3))), dxfattribs={"style": "OpenSans"}).set_placement((d.x , d.y), align=TextEntityAlignment.LEFT)
  mtext.set_bg_color(6, scale=1.5)

  hatch.paths.add_polyline_path(polilineas[i], is_closed=True)
  i = i + 1
doc.saveas("AUTOCAD DE PRUEBA m text.dxf")

###### Creacion del AUTOCAD #######
#########################################################################################
#########################################################################################
from ezdxf.enums import TextEntityAlignment
doc = ezdxf.new("R2018", setup = True)
msp = doc.modelspace()
i = 0
while i < len(resultados_2["pilar"]):
  hatch = msp.add_hatch(color= 253) ### AJUSTAR LOS COLORES
  hatch.set_pattern_fill("ANSI31", scale=0.5, color = 170) ### AJUSTAR LOS COLORES
  a = resultados_2.iloc[i, 0] ## busqueda de la linea 
  b = resultados_2.iloc[i, 1] ## busqueda de la capa 
  c = resultados_2.iloc[i, 2] ## valor del FS
  d = centroides[i]  ### valor de los centroides
  msp.add_lwpolyline(a, close = True, dxfattribs= {"layer": str(b)})
  msp.add_text(("FS :", str(c.round(3))), height= 1, dxfattribs={"style": "LiberationSerif"}
               ).set_placement((d.x , d.y), align=TextEntityAlignment.LEFT)
  hatch.paths.add_polyline_path(polilineas[i], is_closed=True)
  i = i + 1
doc.saveas("AUTOCAD DE PRUEBA color 170.dxf")

"""estandarizado de variables para que tome los colores segun una escala"""

resultados_2["factor de seguridad"]

fs = resultados_2["factor de seguridad"].values

fs

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range= (10,170))

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range= (10,170))

trans_fs = scaler.fit_transform(fs.reshape(-1, 1))

trans_fs_round = trans_fs.round(-1)

###### Creacion del AUTOCAD #######
#########################################################################################
#########################################################################################
from ezdxf.enums import TextEntityAlignment
doc = ezdxf.new("R2018", setup = True)
msp = doc.modelspace()
i = 0
while i < len(resultados_2["pilar"]):
  hatch = msp.add_hatch(color= float(trans_fs_round[i])) ### AJUSTAR LOS COLORES
#  hatch.set_pattern_fill("ANSI31", scale=0.5, color = float(trans_fs_round[i])) ### AJUSTAR LOS COLORES
  a = resultados_2.iloc[i, 0] ## busqueda de la linea 
  b = resultados_2.iloc[i, 1] ## busqueda de la capa 
  c = resultados_2.iloc[i, 2] ## valor del FS
  d = centroides[i]  ### valor de los centroides
  msp.add_lwpolyline(a, close = True, dxfattribs= {"layer": str(b)})
  msp.add_text(("FS :", str(c.round(3))), height= 1, dxfattribs={"style": "LiberationSerif"}
               ).set_placement((d.x , d.y), align=TextEntityAlignment.LEFT)
  hatch.paths.add_polyline_path(polilineas[i], is_closed=True)
  i = i + 1
doc.saveas("AUTOCAD DE PRUEBA DE COLOR VER 7.dxf")

trans_fs = scaler.fit_transform(fs.reshape(-1, 1))

trans_fs

trans_fs_round = trans_fs.round(-1)

trans_fs_round

float(trans_fs_round[0])

"""#creacion del autocad de salida con colores y todo !!!!!!!!!"""

###### Creacion del AUTOCAD #######
#########################################################################################
#########################################################################################
from ezdxf.enums import TextEntityAlignment
doc = ezdxf.new("R2018", setup = True)
msp = doc.modelspace()
i = 0
while i < len(resultados_2["pilar"]):
  hatch = msp.add_hatch(color= float(trans_fs_round[i])) ### AJUSTAR LOS COLORES
#  hatch.set_pattern_fill("ANSI31", scale=0.5, color = float(trans_fs_round[i])) ### AJUSTAR LOS COLORES
  a = resultados_2.iloc[i, 0] ## busqueda de la linea 
  b = resultados_2.iloc[i, 1] ## busqueda de la capa 
  c = resultados_2.iloc[i, 2] ## valor del FS
  d = centroides[i]  ### valor de los centroides
  msp.add_lwpolyline(a, close = True, dxfattribs= {"layer": str(b)})
  msp.add_text(("FS :", str(c.round(3))), height= 1, dxfattribs={"style": "LiberationSerif"}
               ).set_placement((d.x , d.y), align=TextEntityAlignment.LEFT)
  hatch.paths.add_polyline_path(polilineas[i], is_closed=True)
  i = i + 1
doc.saveas("AUTOCAD DE PRUEBA DE COLOR VER 7.dxf")

"""#creacion de la leyenda"""







ezdxf.colors.CYAN

ezdxf.colors.rgb2int((0,0,255))

doc = ezdxf.new("R2000")
msp = doc.modelspace()

# by default a solid fill hatch with fill color=7 (white/black)
hatch = msp.add_hatch(color= 10)
hatch.set_pattern_fill("ANSI31", scale=0.5, color = 3)
# every boundary path is a 2D element
# vertex format for the polyline path is: (x, y[, bulge])
# there are no bulge values in this example
hatch.paths.add_polyline_path(lista_zip, is_closed=True)

doc.saveas("solid_hatch_version 3 color 10.dxf")

doc = ezdxf.new("R2000")
msp = doc.modelspace()

# by default a solid fill hatch with fill color=7 (white/black)
hatch = msp.add_hatch(color=2)

# every boundary path is a 2D element
# vertex format for the polyline path is: (x, y[, bulge])
# there are no bulge values in this example
hatch.paths.add_polyline_path(
    [(0, 0), (10, 0), (10, 10), (0, 10)], is_closed=True
)

doc.saveas("solid_hatch_polyline_path.dxf")











### EXPORTACION DE LOS RESULTADOS EN FORMA DE ACAD ###
import ezdxf

doc = ezdxf.new("R2000")
msp = doc.modelspace()


i = 0
while i <len(resultados_2):
  xx = resultados_2.iloc[i, 0]
  msp.add_lwpolyline(x.append_points(resultados_2.iloc[i, 0][-1]))
  i = i + 1

doc.saveas("polilineas_prueba_1.dxf")











datos

datos = geo.GeoDataFrame(data = datos)

datos

type(datos)

datos.pilar.length

type(datos)

lista_sigma_ci

x

def agregar_geo(x, y):
  i = 0

  while i < len(x):
    if i == "CMET":
      HOLA = y[y["Litologia"] == "CMET"]
      x["Sigma Ci"] = HOLA.iloc[0,1]
      x["mi"] = HOLA.iloc[0, 2]
      x["GSI"] = HOLA.iloc[0, 3]


    if i == "PDI":
      HOLA = y[y["Litologia"] == "PDI"]
      x["Sigma Ci"] = HOLA.iloc[0,1]
      x["mi"] = HOLA.iloc[0, 2]
      x["GSI"] = HOLA.iloc[0, 3]

    i = i + 1 

  return x

agregar_geo(data_resumen2, prop_geo)

lista_sigma_ci

agregar_geo(data_resumen2, prop_geo)

lista1 = []
lista2 = []
lista3 = []

def lectura_geomecanica(x):
  if x["tipo de pilar"] == "CMET":
    lista.append(124, 12, 74)
  if x["tipo de pilar"] == "Dacita":
    lista.append(145, 18.6, 86)